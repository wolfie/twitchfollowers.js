<!DOCTYPE html>
<html>
<head>
    <title>Twitch follower alerts</title>
    <style>
        html {
            margin:0;
            padding:0;
            overflow: hidden;
        }

        #result .error {
            background-color: red;
            color: white;
        }
    </style>
</head>
<body>

<div id="result"></div>
<!--
This tag contains all the JSONP data.
Need to use JSONP to circumvent cross site scripting protections
-->
<div id="data"></div>

<script>
    /*
    TODO: Notice if someone unfollows and another follows instead.
    TODO: Provide a queue of followers
      TODO: announceNewFollowers() --> queue manager
      TODO: announceNewFollower() --> called by queue manager (overrideable)
      TODO: done() --> a callback function to let the queue manager to know that the next follower may be announced
    */

    function Follower(twitchData) {
        this.name = "";
        this.logo = null;
        this.notified = false;

        if (twitchData) {
            this.name = twitchData.user.display_name;
            this.logo = twitchData.user.logo;
            this.notified = twitchData.notifications;
        }
    }

    window.announceNewFollowers = function(followers) {
        followers.forEach(function (follower) {
            var followdiv = document.createElement('div');
            followdiv.textContent = follower.name;
            result.appendChild(followdiv);
        });
        setTimeout(resultClear, 10000);
    };

    window.announceNewFollowersRaw = function(result) {
        var followers = [];
        result.follows.forEach(function(followerData) {
            followers.push(new Follower(followerData));
        });
        window.announceNewFollowers(followers);
    };

    var API = 'https://api.twitch.tv/kraken/channels';
    //var ticklength = 10000; // 10sec in millis
    var ticklength = 300000; // 5min in millis
    var channel = parseChannel();
    var timeoutId = 0;

    window.followersCallback = function(jsonp) {
        error('receiving jsonp data without a properly configured callback')
    };

    function resultClear() {
        while (result.firstChild) {
            result.removeChild(result.firstChild);
        }
    }

    function error(string) {
        console.error(string);

        var errorSpan = document.createElement('span');
        errorSpan.className = 'error';
        errorSpan.textContent = string;

        resultClear();
        result.appendChild(errorSpan);
    }

    function log(string) {
        console.log(string);
    }

    function parseChannel() {
        var channel = location.hash;
        if (channel.trim()) {
            return channel.substr(1);
        } else {
            return null;
        }
    }

    function followers(offset, limit, callback) {
        offset = offset || 0;
        limit = limit || 0;

        var URI = API +
                "/" + channel +
                "/follows" +
                "?offset=" + offset +
                "&limit=" + limit +
                "&direction=asc" +
                "&callback=followersCallback" +
                "&api_version=3" +
                "&time="+(new Date().getTime());
        window.followersCallback = callback;

        // fetch data over JSONP
        var dataScript = document.createElement('script');
        dataScript.src = URI;

        data.innerHTML = '';
        data.appendChild(dataScript);
        log('Fetching new followers with '+URI);
    }

    function tick(previousFollowersCount) {
        window.clearTimeout(timeoutId);
        timeoutId = setTimeout(function() {
            followers(previousFollowersCount, 25, function(result) {
                var newFollowersCount = result._total;
                if (newFollowersCount > previousFollowersCount) {
                    if (window.announceNewFollowersRaw) {
                        resultClear();
                        window.announceNewFollowersRaw(result, result);
                    } else {
                        error('window.announceNewFollowersRaw is not defined');
                    }
                } else {
                    log('No new followers found ('+newFollowersCount+')');
                }
                tick(newFollowersCount);
            });
        }, ticklength);

        var nextTick = new Date();
        nextTick.setMilliseconds(nextTick.getMilliseconds()+ticklength);
        log('Scheduled next tick for '+nextTick);
    }

    function start() {
        log('Searching initial follower count for "'+channel+'"');
        followers(0, 1, function(followers){
            var initCount = followers._total;
            log('Initial follower count: '+initCount);
            tick(initCount);
        });
    }

    function stop() {
        window.clearInterval(timeoutId);
        log('stopped');
    }

    (function() {
        window.onhashchange = function() { window.location.reload() };

        if (!channel) {
            window.location.hash = window.prompt("Which channel to listen to?")
        }

        start();
    })();
</script>
<script src="animation.js"></script>
</body>
</html>